:toc: macro
:toclevels: 4
:tbtc:

= TBTC: A Decentralized Redeemable BTC-backed ERC-20 Token

toc::[]

[abstract]
.Abstract
--
--

== Overview

== Prior Work

* Liquid - centralized, fiat, provable, redeemable
* WBTC - centralized, fiat, provable, redeemable
* Maker - decentralized, synthetic (irredeemable)

downsides of a "fiat" BTC peg

* note this includes all current sidechain implementations AFAIK

downsides of a synthetic BTC

* need more diverse / resilient collateral, and that's difficult to find on-chain
* upsides - there might be some value to having an asset pegged to BTC that doesn't

== Desired Properties

The goal of TBTC is the creation an ERC-20 token that maintains the most
important property of Bitcoin- its status as "hard money".

To maintain the "hard money" status of its backing BTC deposits, TBTC must
remain

* Censorship and seizure resistant, across friendly and unfriendly
jurisdictions
* Inflation-resistant. TBTC may only be minted after proof is provided of a
backing BTC deposit.
* Leverage-resistant. The existence of TBTC shouldn't let a Bitcoin holder
* Without middlemen, in the same sense as Bitcoin. The only rent extraction
should be from the minimal participation of signers required to secure the
network, similar to miners on the Bitcoin network.

Finally, TBTC must be *redeemable*. The ability to trade scrip for its backing
deposit freely is what distinguishes a backed currency from fiat money.

== Developing Intuition: A simple single-signer protocol

To understand how we might develop a protocol and token that satisfies those
requirements, it's useful to consider a simple, under-specified variant that
could theoretically do the job.

Imagine an off-chain actor, which we'll call `Signer`, an Ethereum smart
contract that implements the ERC-20 interface, `PeggedBitcoin`, with ticker
`PBTC`, and another contract with the permission to mint and burn
`PBTC` called `PeggedBitcoinReserve`.

Another off-chain actor, `Depositor`, wants to mint a token on the
`PeggedBitcoin` contract. `Depositor` requests the `PeggedBitcoinReserve`
accept a 1 BTC deposit. `PeggedBitcoinReserve` waits for `Signer` to
acknowledge and return a new BTC address, as well as depositing 150% collateral
of the deposit's value in ETH into the `PeggedBitcoinReserve`. `Depositor`
deposits 1 BTC into the new BTC address, and provides proof to
`PeggedBitcoinReserve` - which in turn mints 1 `PBTC`, sending 0.99 to
`Depositor` and .01 to `Signer` for the convenience.

Withdrawals happen in reverse- any participant can send 1 `PBTC` to
`PeggedBitcoinReserve` with a Bitcoin address. `Signer` pays that Bitcoin
address 1 BTC minus any transaction fees, and provides proof of payment to
`PeggedBitcoinReserve`, which burns the remaining 1 `PBTC`, maintaining a 1:1
backing of `PBTC`. `Signer` is now free to withdraw the corresponding
collateral from `PeggedBitcoinReserve`.

===  Flaws

While this simple design is attractive, it's skipped over some of the more
difficult issues- efficient Bitcoin proof of payment validation on the EVM and
a reliable price feed implementation, for example.

It's also based on a deeply insecure custody solution.

First, the protocol relies on a single signer. If the value of deposits ever
exceeds the value of the collateral `Signer` has put down, there's nothing
stopping `Signer` from walking with the BTC. `Signer` can also decide or be
coerced to censor particular withdrawals, removing any hope of censorship or
seizure resistance.

Second, the protocol relies on a single *hot wallet*. As the market cap of
`PBTC` conceivably grows, the risk due to hacking that wallet increases
tremendously.

Finally, the protocol does nothing to localize failure. If there's an issue
with a single deposit or withdrawal, it could impact the entire `PeggedBitcoin`
supply, blocking all further deposits and withdrawals.

== System Architecture: Designing a robust multi-wallet multi-signer protocol

The rest of this document is devoted to specifying a protocol that addresses
those flaws, providing a robust BTC-backed bearer asset on Ethereum.

At a high level, that means the protocol described must

* have a multi-wallet architecture
* with many geographically distributed signers
* that removes single points of failure

This protocol must also counter the secondary effects of these requirements
and the details we skipped in the single signer example, including multi-signer
payment, a more complex bonding system, an approach for detecting and dealing
with undercollateralized signers, a Bitcoin proof system, and robust handling
of failures on both chains.

Some components necessary to this protocol are described outside this document
and will be assumed. In particular, we assume the existence of

* a well-distributed work token for signer selection
* a random beacon for signer selection
* an efficient distributed key generation protocol on the secp256k1 curve
* an efficient multi-party threshold ECDSA protocol on the secp256k1 curve

all of which are implemented by the Keep network.

The architecture is broken down into

* Deposits
* Signing
* Price feeds
* Wallet and collateral failure
* Redemption

include::deposits/index.adoc[leveloffset=+2]

include::signing/index.adoc[leveloffset=+2]

include::price-feeds/index.adoc[leveloffset=+2]

include::failure/index.adoc[leveloffset=+2]

include::redemption/index.adoc[leveloffset=+2]
