
== Withdrawal Flow

This is the process to redeem a deposit. Once started, redemption cannot be
cancelled, except by proving signer fraud. Cancellation is impossible because
as soon as redemption is requested the keep is permitted to sign, and a
signature (even one neither chain knows about) can't be revoked.

Ergo, cancellation of this process could result in BTC moved from the signers'
address, and an Active Deposit with TBTC outstanding. This would result in a
supply peg-break.

The requestor notifies the _Deposit_ of the bitcoin tx information (fee and
recipient pkh) they are requesting, along with enough TBTC to cover the
outstanding TBTC from the _Deposit_ (counting any existing equity).

=== States

* Flow enterable from
** Active
*** via requestWithdrawal
* In this flow
** Awaiting Withdrawal Signature
*** A withdrawal has been initiated by the Deposit owner
*** The Keep must sign a digest, and return the signature for verification
** Awaiting Withdrawal Proof
*** The Keep has returned a valid signature on the message
*** The Keep must provide a settlement proof
* Can exit flow to
** Fraud Pre-liquidation
*** via an ECDSA or BTC fraud proof
*** via a state timeout
* Reachable end state
** Redeemed
*** By providing a valid proof showing payment to the requestor

=== Internal Transitions
==== provideWithdrawalSignature
* Keep provides a valid ECDSA signature under their pubkey
* called by
** 1 or more keep signers
* args
** bytes _signature
* reads
** address keepAccount
** bytes32 requestedDigest
** uint256 withdrawalRequestTime
*** track what time the most recent signature was requested, so that we have a
    timeout for signers providing the sig
* from
** Awaiting Withdrawal Signature
* to
** Awaiting Withdrawal Proof

==== changeWithdrawalFee
* TODO: should keeps be able to call this after a certain amount of time?
* Requester provides a new fee, requesting a new signature from the Keep
* called by
** deposit owner
** 1 or more keep signers?
* args
** uint256 _newFee
* reads
** bytes requestorPKH
* writes
** uint256 withdrawalRequestTime
* from
** Awaiting Withdrawal Proof
* to
** Awaiting Withdrawal Signature

==== provideWithdrawalProof
* Keep signers provides a valid Bitcoin SPV Proof of payment to the requestor
* called by
** 1 or more keep signers
* args
** bytes _bitcoinTX
** bytes _merkleProof
** bytes _bitcoinHeaders
* reads
** bytes requestorPKH
** uint256 oracleDifficultyReq
** uint256 depositSize
** uint256 fee
* writes
** uint256 balances -- on TBTC ERC20 Contract
*** 1 time for each signer
*** 1 time for the deposit contract
* from
** Awaiting Withdrawal Proof
** Awaiting Withdrawal Signature
* to
** Redeemed

=== External Transitions
==== requestWithdrawal (inbound)
* TODO: link this elsewhere
* Deposit owner requests a withdrawal
* called by
** deposit owner
* args
** uint256 _fee
** bytes _requestorPKH
* reads
** address depositOwner
* writes
** bytes requestor PKH
** uint256 outstandingTBTC
** uint256 withdrawalRequestTime
** uint256 balances -- on TBTC ERC20 Contract
** uint256 totalSupply -- on TBTC ERC20 Contract
* from
** Active
* to
** Awaiting Withdrawal Signature

==== provideECDSAFraudProof (outbound)
* TODO: link this elsewhere
* called by
** anyone
* from
** Awaiting Withdrawal Proof
** Awaiting Withdrawal Signature
* to
** Fraud Pre-liquidation

==== provideSPVFraudProof (outbound)
* TODO: link this elsewhere
* called by
** anyone
* from
** Awaiting Withdrawal Proof
** Awaiting Withdrawal Signature
* to
** Fraud Pre-liquidation
