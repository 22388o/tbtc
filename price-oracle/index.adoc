[#price-oracle]
= Price Oracle


Price feed: 
- is used simply for calculating the value in native chain currency of BTC. 
- the usage is something along the lines of `+getPrice() * COLLATERAL_VALUE+`. 
- is maintained by a single trusted actor (v1) 
- will be governed in future (as in MakerDAO)

A pseudo-interface:

[source,solidity]
----
interface PriceFeed {
    function getPrice() external view returns (uint128);
    function updatePrice(uint128 price) public;
}
----

*Resources*:

* https://developer.makerdao.com/feeds/[MakerDAO Price Feed docs]

== updatePrice

MakerDAO implements two additional prerequisites on `+updatePrice+`: 
1. Source price differs to the most recently submitted price by more than the defined amount (currently 1%) 
2. Last price update was more than 6 hours ago.

#1 avoids the network’s nodes from spuriously recomputing things for
price changes of negligible magnitudes.

#2 is more a mitigator from DoS attacks of feed providers.

== getPrice

Maker also implements a price expiration time (`zzz`) - calls to the oracle's getPrice REVERT in the case the price is out-of-date. 

== Governance

Eventually KEEP holders will govern a couple aspects of tBTC, including
the price feed mechanics. The price feed underlies the entire
cryptoeconomic proposition of tBTC and its malfunctioning is a
systematic risk.

MakerDAO has quite an effective risk team, evidenced by their
preparation for black swans and the like. A couple concerns we should
analyse:

* *Access control*: how do we design for the potential that we will have
to change the owner, in the case of hacking etc.
* *Aggregating price signals*: we at some point move to a Medianizer
model from MakerDAO in future (else it’s not really decentralized BTC).
There’s talk of using on-chain markets as signals too (ie. a Uniswap
exchange). Do we want the design to allow this to be "`governed in`"?